#!/usr/bin/env python

import sys, socket, select, time, json, random

# node types
FOLLOWER = 'follower'
CANDIDATE = 'candidate'
LEADER = 'leader'

# RCP types
REQUEST_VOTE = 'requestVote'
VOTE = 'vote'
NO_VOTE = 'noVote'
APPEND_ENTRY = 'appendEntry'
ACCEPT_APPEND_ENTRY = 'acceptAppendEntry'
REJECT_APPEND_ENTRY = 'rejectAppendEntry'

myNodeType = FOLLOWER
electionTimeout = float(random.randint(500, 1000)) / 1000
print(electionTimeout)
currentTerm = 0
votedFor = None
myVotes = 1
LEADER_UNKNOWN = 'FFFF'
leader = LEADER_UNKNOWN

# Your ID number
my_id = sys.argv[1]

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

voteRequestWhitelist = replica_ids[:]

# number of nodes needed for majority
majority = int((len(replica_ids) + 1) / 2) + 1

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

messageCount = 0
def generateMID():
	global messageCount
	messageCount += 1
	return int(str(my_id) + str(messageCount))

def sendMessage(msg):
	global sock
	if sock.send(json.dumps(msg)) == 0:
		print "unable to send, trying again"
		sock.close()
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		sock.connect(my_id)
		sendMessage(msg)
	print '%s sending %s message to %s' % (msg['src'], msg['type'], msg['dst'])

def handleRequestVote(msg):
	global votedFor
	if currentTerm  <=  msg['term'] and (not votedFor or votedFor == msg['candidateId']): # also check candidate's log is at least as up-to-date as ours (also do we need to update our term???)
		# vote for them!
		votedFor = msg['candidateId']
		response = {'src': my_id, 'dst': msg['src'], 'leader': LEADER_UNKNOWN, 'type': VOTE, 'term': msg['term'], 'candidateId': votedFor, 'MID': msg['MID']}
		sendMessage(response)
	else:
		# reply false
		print my_id, "replied false to", msg['candidateId'], "voted for", votedFor
		response = {'src': my_id, 'dst': msg['src'], 'leader': LEADER_UNKNOWN, 'type': NO_VOTE, 'term': msg['term'], 'candidateId': msg['candidateId'], 'MID': msg['MID']}
		sendMessage(msg)

def handleAppendEntry(msg):
	global leader, myNodeType, currentTerm, voteRequestWhitelist, votedFor
	if msg['term'] < currentTerm: 
		response = {'src': my_id, 'dst': msg['dst'], 'leader': leader, 'type': REJECT_APPEND_ENTRY, 'MID': msg['MID']}
		sendMessage(msg)
	# also check prevlogidx and conflicting log entries
	else:
                # append any new entries to log and update commitidx
		leader = msg['leader']
		myNodeType = FOLLOWER
		currentTerm = msg['term']
		votedFor = None
		print my_id, "RECOGNIZING", leader, "AS LEADER"
		print my_id, "updated term to", currentTerm
		voteRequestWhitelist = replica_ids[:]

def handleVote(msg):
	global myVotes
	if msg['term'] == currentTerm:
		voteRequestWhitelist.remove(msg['src'])
		myVotes += 1
		if myVotes >= majority:
			becomeLeader()

def handleNoVote(msg):
	global voteRequestWhitelist
	if msg['term'] == currentTerm:
		voteRequestWhitelist.remove(msg['src'])
		

def becomeLeader():
	global myNodeType, electionTimeout, votedFor, myVotes, voteRequestWhitelist
	print "BECOMING LEADER", my_id
	myNodeType = LEADER
	electionTimeout = random.randint(150,300) / 1000
	votedFor = None
	myVotes = 1
	sendHeartbeat()
	voteRequestWhitelist = replica_ids[:]

def sendHeartbeat():
	for id in replica_ids:
		msg = {'src': my_id, 'dst': id, 'leader': my_id, 'type': APPEND_ENTRY, 'term': currentTerm, 'MID': generateMID()}
		sendMessage(msg)

last = 0
while True:
	ready = select.select([sock], [], [], 0.1)[0]	
	if sock in ready:
		msg_raw = sock.recv(32768)
		if len(msg_raw) == 0: continue
		last = time.time()
		msg = json.loads(msg_raw)
		if 'term' in msg and msg['term'] > currentTerm:
			currentTerm = msg['term']
		# For now, ignore get() and put() from clients
		if msg['type'] in ['get', 'put']:
			pass
		elif msg['type'] == REQUEST_VOTE:
			handleRequestVote(msg)
		elif msg['type'] == VOTE:
			if not myNodeType == LEADER: handleVote(msg)
		elif msg['type'] == APPEND_ENTRY:
			handleAppendEntry(msg)
		elif msg['type'] == NO_VOTE:
			handleNoVote(msg)

	if not myNodeType == LEADER:
		clock = time.time()
		if clock - last > electionTimeout:
                        print my_id, "timed out after"
			print electionTimeout
       	                leader = LEADER_UNKNOWN
			electionTimeout = float(random.randint(500, 1000)) / 1000
			print "NEW ELECTION TIMEOUT FOR", my_id
			print electionTimeout
			currentTerm += 1
			myNodeType = CANDIDATE
			votedFor = my_id
			# issue RequestVote RPCs in parallel (TODO) to each of the other servers in the cluster
			for id in replica_ids:
				msg = {'src': my_id, 'dst': id, 'leader': LEADER_UNKNOWN, 'type': REQUEST_VOTE, 'term': currentTerm, 'candidateId': my_id, 'MID': generateMID()}
				sendMessage(msg)

			
			
